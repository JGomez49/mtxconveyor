

<%- include ('partials/header.ejs') %>

    <div class="container bg-dark">

        <h2 class="pt-4">Upload Schedule</h2>

        <p class="mb-4">USER: <%= user.name %></p>
        <!-- <pre><%= note %></pre> -->

        <div class="row m-4">

            <form action="/notes/uploadSchedule" method="POST" enctype="multipart/form-data" class="mb-4">
                <div class="card mb-3">
                    <div class="card-body">
                        <div class="input-group mb-3">
                            <input
                                type="file" 
                                accept=".csv"
                                name="csvFile" 
                                class="form-control" 
                                id="csvFile"
                            >
                        </div>
                    </div>
                </div>
                <div class="d-grid gap-2">
                    <!-- <button class="btn btn-success" type="submit">Upload</button> -->
                    <a href="/notes" class="btn btn-primary btn-block my-2">Back</a>
                </div>
            </form>





            <div class="accordion mb-4" id="accordionExample">
              <div class="accordion-item _bg-dark border-0">
                <h2 class="accordion-header" id="headingOne">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" style="background-color: #1a1a1a; color: #ffffff;" 
                            data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                    ðŸ“‹ Table
                    </button>
                </h2>
                <div id="collapseOne" class="accordion-collapse collapse _show" aria-labelledby="headingOne">
                    <div class="accordion-body">
                    <table 
                      id="csvTable" 
                      class="table table-dark table-striped table-bordered">
                    </table>
                    </div>
                </div>
              </div>
            </div> 
        </div> <!-- Class -->
    </div> <!-- Container -->

    <div id="chartContainer" class="m-3"></div>



    
  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0/dist/chartjs-plugin-annotation.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0"></script>






  <script>
    let chartInstances = [];

    function excelSerialToDate(serial) {
      const utcMillis = (serial - 25569) * 86400 * 1000;
      const d = new Date(Math.round(utcMillis));
      return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
    }
    function parseExcelDate(value) {
      if (value instanceof Date && !isNaN(value)) return value;
      if (typeof value === "number") return excelSerialToDate(value);
      const parsed = Date.parse(value);
      if (!isNaN(parsed)) return new Date(parsed);
      return null;
    }

    document.getElementById('csvFile').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;

      Papa.parse(file, {
        complete: function(results) {
          let data = results.data;
          data = data.filter(row => row.some(cell => cell.trim() !== ""));

          const deleteCols = [1,2,3,4,5,6,7,8,9,11,12,14,15,
                              18,19,20,21,22,23,26,27,28];

          // keep columns 0, 10, 13, 16, 17, 24, 25 (Rig(0), DP(1), Type(2), ___(3), VP(4), Start(5), Site(6), Well(7))
          
          data = data.map(row => row.filter((_, idx) => !deleteCols.includes(idx)));

          //console.log(data[3]);

          data = data.map((row, rIdx) => {
            if (rIdx === 0) {
              row.splice(3, 0, "Duration");
            } else {
              let found = "";
              for (let i = 3; i < row.length; i++) {
                if (!isNaN(row[i]) && row[i].trim() !== "") {
                  found = parseFloat(row[i]);
                  break;
                }
              }
              row.splice(3, 0, found || 0);
            }
            return row;
          });

          //console.log(data[3]);

          data = data.map((row, rIdx) => {
            if (rIdx === 0) return row;
            const rig = row[0] ?? "";
            const dp = row[1] ?? "";
            const type = row[2] ?? "";
            const duration = row[3] ?? 0;
            const vp = row[4] ?? "";
            const start = row[5] ?? "";
            const site = row[6] ?? "";
            const well = row[7] ?? "";
            return [rig, dp, type, duration, vp, start, site, well];
          });

          //console.log(data[2]);
          data = data.filter((_, idx) => idx === 0 || (idx - 3) % 3 === 0);

          //console.log(data); // Final cleaned data preview <-------------------------------------

          // console.log("Uploading schedule to server...", data);
          console.log("Uploading schedule to server");

          // ðŸš€ Upload cleaned schedule to server
          fetch("/notes/uploadSchedule", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ data }),
          })
          .then(res => {
            if (res.redirected) {
              window.location.href = res.url; // Follow redirect
            }
          })
          .catch(err => console.error("Upload error:", err));
          // ðŸš€ End upload

          let header = ["Rig", "DP", "Type", "Duration", "VP", "Start", "Site", "Well"];
          let finalData = [header, ...data.slice(1)];

          renderTable(finalData);
          renderGantts(finalData);

          // alert("Schedule processed and uploaded.");
        }
      });
    });





    function renderTable(data) {
      const table = document.getElementById('csvTable');
      table.innerHTML = "";
      data.forEach((row, rowIndex) => {
        const tr = document.createElement('tr');
        row.forEach(cell => {
          const td = document.createElement(rowIndex === 0 ? 'th' : 'td');
          td.textContent = cell;
          tr.appendChild(td);
        });
        table.appendChild(tr);
      });
    }




    // Render Gantt Charts
    function renderGantts(data) {
      chartInstances.forEach(c => c.destroy());
      chartInstances = [];
      const container = document.getElementById("chartContainer");
      container.innerHTML = "";

      // header = ["Rig", "DP", "Type", "Duration", "VP", "Start", "Site", "Well"];
      // columns 0, 10, 13, 16, 17, 24, 25 (Rig(0), DP(1), Type(2), ___(3), VP(4), Start(5), Site(6), Well(7))

      // Group by VP and then by Rig
      const vpMap = {};
      for (let i = 1; i < data.length; i++) {
        const rig = data[i][0];
        const dp = data[i][1];
        const type = data[i][2];
        const duration = Number(data[i][3]);
        const vp = data[i][4];
        const start = parseExcelDate(data[i][5]);
        const site = data[i][6];
        const well = data[i][7];
        if (!start) continue;
        if (!vpMap[vp]) vpMap[vp] = {};
        if (!vpMap[vp][rig]) vpMap[vp][rig] = [];
        vpMap[vp][rig].push({ dp, type, duration, vp, start, site, well });
      }

      // Get date boundaries
      const today = new Date();
      const twoMonthsLater = new Date(today.getFullYear(), today.getMonth() + 2, today.getDate());
      const threeMonthsLater = new Date(today.getFullYear(), today.getMonth() + 3, today.getDate());
      const sixMonthsLater = new Date(today.getFullYear(), today.getMonth() + 6, today.getDate());

      // For each VP, create a chart
      Object.keys(vpMap).forEach(vp => {
        const datasets = [];
        const colors = [];
        const colorCounts = { blue: 0, red: 0, green: 0, yellow: 0 };
        const rigs = Object.keys(vpMap[vp]);


        rigs.forEach(rig => {
          vpMap[vp][rig].forEach(siteObj => {
            const end = new Date(siteObj.start.getTime() + siteObj.duration * 86400000);
            const dpValue = siteObj.dp ? siteObj.dp.toString().trim() : "";
            const isEmptyDP = !dpValue || dpValue === "***";
            const type = siteObj.type;

            // console.log(`Rig: ${rig}, 
            //             VP: ${vp}, 
            //             Start: ${siteObj.start.toLocaleDateString()}, 
            //             Duration: ${siteObj.duration}, 
            //             DP: ${dpValue}, 
            //             Site: ${siteObj.site}, 
            //             Well: ${siteObj.well}, 
            //             type: ${siteObj.type} `);

            datasets.push({ 
              y: rig, 
              x: [siteObj.start, end], 
              site: siteObj.site.substring(0,5),
              details: {
                Rig: rig,
                VP: vp,
                Start: siteObj.start.toLocaleDateString(),
                Duration: siteObj.duration,
                DP: dpValue,
                type: siteObj.type,
                Site: siteObj.site,
                Well: siteObj.well
              }
            });


            // Determine color based on DP and Type
            if (!isEmptyDP && (type === "EXEC" || type === "PRELIM-IR" || type === "PRELIM")) {
              colors.push("#0084c7"); // Blue
              datasets[datasets.length - 1].flash = false;
              colorCounts.blue++;
            } else if (isEmptyDP && (type === "EXEC" || type === "PRELIM-IR" || type === "PRELIM" || type === "")) {
              colors.push("#ff4c4c"); // Red
              datasets[datasets.length - 1].flash = false;
              colorCounts.red++;
            } else if (type === "FINAL") {
              colors.push("#4caf50"); // Green
              datasets[datasets.length - 1].flash = false;
              colorCounts.green++;
            } else {
              colors.push("#ffff00"); // Yellow fallback
              datasets[datasets.length - 1].flash = false;
              colorCounts.yellow++;
            }



          });
        });

        // Date boundaries
        const minDate = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 7);
        const maxDate = sixMonthsLater;

        // Create container for each VP
        const title = document.createElement("h3");
        title.textContent = `VP: ${vp}`;
        container.appendChild(title);


        // Create canvas
        const canvas = document.createElement("canvas");
        canvas.height = Math.max(200, rigs.length * 40);
        container.appendChild(canvas);

        // Calculate total bars
          const totalBars = colorCounts.blue + colorCounts.red + colorCounts.green + colorCounts.yellow;

          // Create summary table
          const summaryTable = document.createElement("table");
          summaryTable.className = "table table-dark table-sm table-bordered mt-2";
          summaryTable.innerHTML = `
            <thead>
              <tr>
                <th style="background-color:#0084c7">Done</th>
                <th style="background-color:#ff4c4c">In-Progress</th>
                <th style="background-color:#4caf50">Sent</th>
                <th style="color: #1a1a1a; background-color:#ffff00">Need Info.</th>
                <th>Total</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>${colorCounts.blue}</td>
                <td>${colorCounts.red}</td>
                <td>${colorCounts.green}</td>
                <td>${colorCounts.yellow}</td>
                <td><b>${totalBars}</b></td>
              </tr>
            </tbody>
          `;
          container.appendChild(summaryTable);

          // Create pie chart canvas (smaller size)
          const pieCanvas = document.createElement("canvas");
          pieCanvas.style.maxWidth = "300px";   // shrink width
          pieCanvas.style.maxHeight = "300px";  // shrink height
          pieCanvas.className = "mb-4";         // spacing
          container.appendChild(pieCanvas);

          // Build pie chart
          new Chart(pieCanvas.getContext("2d"), {
            type: "pie",
            data: {
              // labels: ["Blue", "Red", "Green", "Yellow"],
              labels: ["Done", "In-progress", "Sent", "Need Info."],
              datasets: [{
                data: [
                  colorCounts.blue,
                  colorCounts.red,
                  colorCounts.green,
                  colorCounts.yellow
                ],
                backgroundColor: ["#0084c7", "#ff4c4c", "#4caf50", "#ffff00"],
                borderColor: "#222",
                borderWidth: 1
              }]
            },
            options: {
              plugins: {
                legend: {
                  position: "bottom",
                  labels: { color: "#fff" },
                },
                datalabels: {
                  color: "#000",
                  font: { weight: "bold" },
                  formatter: (value, ctx) => {
                    let total = ctx.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                    let percentage = total > 0 ? (value / total * 100).toFixed(1) + "%" : "0%";
                    return percentage;
                  }
                }
              }
            },
            plugins: [ChartDataLabels]
          });


        // Create Chart
        const ctx = canvas.getContext("2d");
        const chart = new Chart(ctx, {
          type: "bar",
          data: {
            datasets: [{
              label: "Schedule",
              data: datasets,
              backgroundColor: colors,   // <-- per-bar colors
              borderRadius: 6,
              borderSkipped: false,
              borderColor: "#000000",
              borderWidth: 1,
              parsing: { xAxisKey: "x", yAxisKey: "y" }
            }]
          },
          options: {
            indexAxis: "y",
            responsive: false,
            maintainAspectRatio: false,
            scales: {
              x: {
                type: "time",
                time: { unit: "day", stepSize: 1, tooltipFormat: "dd-MMM-yyyy", displayFormats: { day: "dd-MMM" } },
                min: minDate,
                max: maxDate,
                ticks: { color: "#ccc" },
                grid: { color: "#333" }
              },
              y: {
                type: "category",
                labels: rigs,
                ticks: { color: "#ccc", font: { weight: "bold" } },
                grid: { color: "#333" }
              }
            },
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const d = ctx.raw.details;
                    return [
                      `Rig: ${d.Rig}`,
                      `VP: ${d.VP}`,
                      `Start: ${d.Start}`,
                      `Duration: ${d.Duration} days`,
                      `DP: ${d.DP}`,
                      `Site: ${d.Site}`,
                      `Well: ${d.Well}`,
                      `Type: ${d.type}`
                    ];
                  }
                }
              },
              datalabels: {
                anchor: "center",
                align: "center",
                color: "#000",
                backgroundColor: "rgba(255,255,255,0)",
                borderRadius: 4,
                padding: 2,
                font: { weight: "bold" },
                formatter: (value) => value.site
              },
              annotation: {
                annotations: {
                  futureBox: {
                    type: "box",
                    xMin: twoMonthsLater,
                    xMax: threeMonthsLater,
                    backgroundColor: "rgba(255,0,0,0.15)",
                    borderWidth: 0.5,
                    borderColor: "red",
                  },
                  todayLine: {
                    type: "line",
                    xMin: today, xMax: today,
                    borderColor: "red", borderWidth: 2,
                    label: { enabled: true, content: "Today", position: "start", color: "red" }
                  }
                }
              },
              zoom: {
                zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: "x" },
                pan: { enabled: true, mode: "x" },
                limits: { x: { min: minDate, max: maxDate } }
              }
            },
            barThickness: 18,
            animation: true,
            hover: { mode: null}
          },
          plugins: [ChartDataLabels]
        });
        chartInstances.push(chart);
      });
    }




    // ðŸš¨ Animate flashing bars
      let flashState = true;
      setInterval(() => {
        chartInstances.forEach(chart => {
          chart.data.datasets[0].data.forEach((d, i) => {
            if (d.flash) {
              chart.data.datasets[0].backgroundColor[i] = flashState ? "#ff4c4c" : "#ff4c3c"; // Toggle between red and white
            }
          });
          chart.update("none"); // update without animation
        });
        flashState = !flashState;
      }, 1000); // toggle every 1 second


  </script>

</main>
</body>
</html>







<!-- . -->


<%- include ('partials/footer.ejs') %>